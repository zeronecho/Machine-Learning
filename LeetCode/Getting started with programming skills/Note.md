# 力扣编程能力入门学习笔记

记录不完全，仅作为学习参考使用。

# DAY 2：运算符

## 191. 位1的个数

### 进制转换

Python中可以使用以下内置函数实现不同进制的转换：

1. `bin(x)`：将整数x转换为二进制字符串表示。
2. `oct(x)`：将整数x转换为八进制字符串表示。
3. `hex(x)`：将整数x转换为十六进制字符串表示。
4. `int(x, base)`：将字符串x转换为base进制下的整数，其中base取值为2-36，默认为10。

需要注意的是，这些函数的返回值都是字符串类型。

### 字符串切片

字符串切片是Python中用于从一个字符串中获取子字符串的一种方法。它通过指定字符串的开始和结束位置来获取子字符串。字符串切片的基本语法是`[start:end:step]`，其中`start`是开始位置，`end`是结束位置（不包括该位置的字符），`step`是步长（即每隔多少个字符取一个字符，默认为1）。

例如，对于字符串s="Hello, World!"，要获取其前5个字符可以使用`s[0:5]`或者`s[:5]`，两者的结果都是"Hello"；要获取其第6到第11个字符可以使用s[6:12]或者`s[6:-1]`，两者的结果都是"World"。需要注意的是，如果使用负数作为`start`或`end`，则表示从字符串末尾开始计数。

此外，还可以使用步长来获取一定间隔的字符，例如s[::2]将返回`"Hlo ol!"`，表示每隔一个字符取一个字符。如果步长为负数，则表示从字符串的末尾开始取字符，例如s[::-1]将返回`"!dlroW ,olleH"`，表示将字符串颠倒过来。

1. 只保留字符串前两个字符的代码：`bin(n)[:2]`
2. 只保留最后两个字符的代码：`bin(n)[-2:]`
3. 去掉前两个字符，其他都保留的代码：`bin(n)[2:]`
4. 去掉最后两个字符，其他都保留的代码：`bin(n)[:-2]`

### 位运算

位运算是指直接对二进制位进行操作的运算。常见的位运算符包括按位与（&）、按位或（|）、按位异或（^）、左移位（<<）和右移位（>>）等。位运算可以用来进行二进制数的操作，比如求补码、检测二进制数中的某一位是否为1等等。在编程中，位运算常常被用来进行优化和加密等操作。

在Python中，与1进行按位与运算是指将一个整数的二进制表示的最低位（即最右边的一位）与二进制表示的数字1的最低位进行按位与运算，得到的结果为0或1，取决于这个整数的二进制表示的最低位是否为1。例如，对于整数5（二进制表示为101），与1进行按位与运算的结果是1，对于整数4（二进制表示为100），与1进行按位与运算的结果是0。

位运算是对二进制数进行的运算，它的特性如下：

1. 速度快：位运算可以快速处理大量的位操作，比其他运算符（如加、减、乘、除）要快很多。
2. 位操作：位运算符包括按位与(&)、按位或(|)、按位异或(^)、按位取反(~)、左移位(<<)和右移位(>>)等。
3. 二进制转换：位运算可以实现二进制数和十进制数之间的相互转换，从而方便进行数值计算。
4. 操作位数：位运算可以操作数据的每一位，而其他运算符只能操作整个数据，因此位运算更加灵活。
5. 原地操作：位运算可以在原始数据上进行操作，不需要创建额外的变量或数据结构，从而节省内存。
6. 位掩码：位运算可以使用位掩码技术来提取、设置或清除数据的特定位，从而实现对数据的精细控制。

## 1281. 整数的各位积和之差

### 右移一位

对于十进制的数字，去掉最低位的数字可以使用 `n // 10`，其中 `//` 是整除运算符，相当于向下取整的除法。这个操作相当于将数字末尾的一位数字去掉。

而对于二进制的数字，右移一位可以使用 `n >> 1`，其中 `>>` 是右移运算符，相当于将数字的所有二进制位向右移动一位，去掉最低位的数字。

# DAY 3：条件语句

## 1779. 找到最近的有相同 X 或 Y 坐标的点

### 处理二维数组的函数() 

在Python中，常用的对二维数组进行处理的相关函数包括：

1. `len()`：用于获取二维数组的长度，即二维数组中子数组的个数。
2. `append()`：用于向二维数组中添加一个新的子数组。
3. `extend()`：用于向二维数组中添加多个新的子数组。
4. `insert()`：用于在指定位置向二维数组中插入一个新的子数组。
5. `pop()`：用于删除二维数组中指定位置的子数组。
6. `remove()`：用于删除二维数组中第一个匹配指定元素的子数组。
7. `count()`：用于计算二维数组中指定元素出现的次数。
8. `index()`：用于返回二维数组中第一个匹配指定元素的子数组的位置。
9. `copy()`：用于复制二维数组。
10. `clear()`：用于清空二维数组中的所有子数组。

需要注意的是，以上函数都是针对列表对象而言的，而在Python中没有内置的二维数组类型。因此，如果需要使用二维数组，一般会借助列表来模拟实现。

# DAY 4：循环

## 202. 快乐数

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

### 题解

算法分为两部分，我们需要设计和编写代码。

给一个数字 n，它的下一个数字是什么？按照一系列的数字来判断我们是否进入了一个循环。
第 1 部分我们按照题目的要求做数位分离，求平方和。

第 2 部分可以使用哈希集合完成。每次生成链中的下一个数字时，我们都会检查它是否已经在哈希集合中。

如果它不在哈希集合中，我们应该添加它。
如果它在哈希集合中，这意味着我们处于一个循环中，因此应该返回 false。
我们使用哈希集合而不是向量、列表或数组的原因是因为我们反复检查其中是否存在某数字。检查数字是否在哈希集合中需要 O(1)O(1)O(1) 的时间，而对于其他数据结构，则需要 O(n)O(n)O(n) 的时间。选择正确的数据结构是解决这些问题的关键部分。

### 哈希集合

**哈希集合**（Hash Set）是一种基于哈希表实现的数据结构，它可以支持常数时间内的元素插入、删除和查找操作。哈希集合的主要特点是它存储的元素是无序的，并且不允许出现重复元素。

哈希集合内部使用哈希函数将元素映射到哈希表中的位置。哈希函数的设计需要满足以下两个条件：

1. 相同的元素应该映射到相同的位置，这样才能保证查找操作的正确性。
2. 不同的元素应该尽可能均匀地映射到不同的位置，这样才能避免哈希冲突，提高哈希集合的性能。

在哈希集合中，每个元素对应一个唯一的键值（Key），键值可以是任意类型的数据，例如整数、字符串、元组等等。哈希函数根据键值计算出一个哈希值（Hash Value），哈希值是一个固定长度的整数，它可以唯一地标识一个元素。哈希表是一个由桶组成的数组，每个桶对应一个哈希值，存储具有相同哈希值的元素。

当要插入一个新元素时，哈希集合先根据键值计算出哈希值，然后将元素插入到哈希表中对应的桶中。如果桶中已经有了相同的元素，则不进行插入操作。当要查找一个元素时，哈希集合先根据键值计算出哈希值，然后在哈希表中查找对应的桶。如果桶中有元素且元素的键值与要查找的元素的键值相同，则返回该元素。如果桶中没有元素或者元素的键值不匹配，则认为该元素不存在于哈希集合中。

**哈希集合在很多场景下都可以用到**，例如：

1. 去重：可以使用哈希集合来快速去除重复元素，只需要将元素依次插入到哈希集合中，已经存在的元素会被忽略掉。
2. 查找：可以使用哈希集合来快速查找元素，只需要将元素作为键插入到哈希集合中，然后通过键来查找对应的值。
3. 计数：可以使用哈希集合来对元素进行计数，只需要将元素作为键，出现的次数作为值，插入到哈希集合中，然后通过键来获取对应的值。
4. 缓存：可以使用哈希集合来实现缓存，只需要将键值对插入到哈希集合中，然后通过键来获取对应的值。在需要使用缓存的时候，首先检查哈希集合中是否存在对应的键，如果存在，则返回对应的值，否则需要重新计算值并插入到哈希集合中。

哈希集合是一种以键值对形式存储数据的数据结构，通过哈希函数将键映射到一个桶（bucket）或槽（slot）中，存储的数据可以快速地进行查找、插入、删除等操作。**具体的使用方法**如下：

1. 创建哈希集合：使用`set()`函数或`{}`创建一个空的哈希集合，或者在创建时直接添加元素。

```python
hash_set = set()  # 创建一个空的哈希集合
hash_set = {1, 2, 3}  # 创建一个包含元素1、2、3的哈希集合
```

1. 添加元素：使用`add()`函数向哈希集合中添加一个元素。

```python
hash_set = set()
hash_set.add(1)  # 向哈希集合中添加元素1
```

1. 删除元素：使用`remove()`函数删除哈希集合中的一个元素。

```python
hash_set = {1, 2, 3}
hash_set.remove(2)  # 删除哈希集合中的元素2
```

1. 判断元素是否存在：使用`in`关键字或`__contains__()`函数判断一个元素是否在哈希集合中。

```python
hash_set = {1, 2, 3}
print(2 in hash_set)  # True
print(hash_set.__contains__(4))  # False
```

1. 遍历哈希集合：使用`for`循环遍历哈希集合中的所有元素。

```python
hash_set = {1, 2, 3}
for x in hash_set:
    print(x)
```

1. 获取哈希集合的大小：使用`len()`函数获取哈希集合中元素的数量。

```python
hash_set = {1, 2, 3}
print(len(hash_set))  # 3
```

哈希集合在算法和数据结构中有着广泛的应用，如查找、去重、计数等。在 Python 中，哈希集合通过内置的`set()`函数或使用花括号`{}`来创建。哈希集合具有快速的查找、插入、删除等操作，时间复杂度均为 O(1)，是一种非常实用的数据结构。

**普通集合**通常是基于红黑树、AVL树等平衡二叉树实现的，它们的特点是有序、稳定、插入和查询操作的时间复杂度是 O(logn)。

而哈希集合是基于哈希表实现的，它的特点是无序、不稳定、插入和查询操作的时间复杂度是 O(1)，而哈希表最坏的情况下查询和插入的时间复杂度可以达到 O(n)。

因此，在实际应用中，如果对元素的顺序没有要求，且对于查询和插入操作的时间效率要求比较高时，可以优先选择使用哈希集合。如果对元素的顺序有要求，则需要选择普通集合。

**企业面试**时，关于哈希集合的考点通常包括以下几个方面：

1. 哈希函数的设计和实现。面试官可能会让面试者自己设计一个哈希函数，或者询问哈希函数的时间复杂度、空间复杂度等问题。

   通常来说，哈希函数的时间复杂度为 O(1)，即不会随着输入数据的增加而产生明显的时间复杂度增长。而哈希函数的空间复杂度则取决于哈希表的大小以及散列均匀程度等因素，一般情况下为 O(n)。

2. 哈希集合的使用场景。面试官可能会让面试者结合具体的场景，介绍哈希集合的使用方法以及优缺点。

   **哈希集合的优点**：

   1. 快速的插入和查找：哈希集合中的元素是通过哈希函数分布在哈希表中的，因此插入和查找的时间复杂度为 O(1)，非常快速。
   2. 支持高效的集合操作：哈希集合可以进行高效的集合操作，比如交集、并集、差集等。
   3. 适用于大数据量：当数据量较大时，哈希集合仍然可以保持较好的性能，因为它的查询时间与数据量大小无关。

   **哈希集合的缺点**：

   1. 哈希冲突：哈希函数不可能完美地将所有的元素映射到不同的哈希桶中，有些元素可能会被哈希函数映射到同一个哈希桶中，这就是哈希冲突。哈希冲突会影响哈希集合的查询和插入效率。
   2. 哈希函数的设计：哈希函数的设计会影响哈希集合的效率，一个好的哈希函数可以尽量减少哈希冲突，提高哈希集合的性能。但是，设计一个好的哈希函数并不是一件容易的事情。
   3. 不支持有序性：哈希集合中的元素是无序的，如果需要有序的集合，就需要选择其他的数据结构。

3. 哈希集合的操作和常见问题。面试官可能会让面试者手写哈希集合的实现代码，或者让面试者解决一些与哈希集合相关的问题，例如哈希冲突、哈希集合大小的估算等。

   哈希冲突指的是当使用哈希函数将不同的键映射到同一个索引或桶中时发生的现象。这种情况会导致哈希表的性能下降，因为需要额外的时间来处理哈希冲突。哈希函数本质上是将任意长度的输入映射到固定长度的输出。由于输入的长度是不确定的，因此很难避免哈希冲突的发生。通常，哈希函数的设计和实现需要尽可能地减少冲突的发生。常见的解决哈希冲突的方法有开放定址法和链式地址法。

   哈希集合大小的估算可以通过负载因子（load factor）来计算。负载因子是哈希表中元素数量与表格大小（即哈希槽的数量）之比。通常情况下，负载因子在 0.7 左右时，哈希表的性能最佳。假设哈希表大小为 n，元素个数为 m，则负载因子为 m/n。因此，可以通过负载因子和元素数量来估算哈希表大小，公式为 n=m/负载因子。例如，假设有一个哈希集合，其中包含 10000 个元素，我们希望将负载因子设置为 0.7。则哈希表大小为 n=10000/0.7=14285（向上取整）。因此，可以将哈希表大小设置为 14285，以便在保持高性能的同时存储足够的元素。

4. 哈希集合和其他数据结构的比较。面试官可能会让面试者比较哈希集合和其他数据结构（例如数组、链表、二叉树等）的优缺点，以及它们在不同场景下的应用。

   哈希集合：

   优点：

   - 可以快速的进行添加、删除、查找操作。
   - 基于哈希函数，可以对大数据进行高效的分组和分类。
   - 可以进行去重操作。

   缺点：

   - 哈希函数的设计和冲突处理需要花费一定的时间和精力。
   - 无法进行有序遍历。
   - 哈希表的实现需要额外的空间。

   适用场景：

   - 需要快速进行查找、添加、删除等操作，且不需要有序遍历的场景。
   - 需要进行去重操作的场景。
   - 需要进行高效的分组和分类的场景。

   数组：

   优点：

   - 可以随机访问元素，查找效率高。
   - 内存连续，可以利用 CPU 缓存，访问效率高。

   缺点：

   - 插入和删除操作需要移动大量元素。
   - 无法动态扩容。

   适用场景：

   - 需要随机访问元素，且元素数量较少的场景。
   - 元素数量已知，不需要动态扩容的场景。

   链表：

   优点：

   - 插入和删除操作效率高。
   - 可以动态扩容。

   缺点：

   - 随机访问元素效率低。
   - 链表节点需要额外的空间存储指针信息。

   适用场景：

   - 需要频繁进行插入和删除操作的场景。
   - 元素数量不确定，需要动态扩容的场景。

   二叉树：

   优点：

   - 可以进行有序遍历。
   - 插入和删除操作效率较高。

   缺点：

   - 查找效率低于哈希集合和数组。
   - 树的高度可能不均衡，导致性能下降。

   适用场景：

   - 需要有序遍历元素的场景。
   - 元素数量不确定，需要动态扩容的场景。

   综上所述，不同的数据结构各有优缺点，在使用时需要根据场景需求来选择合适的数据结构。

## 1790. 仅执行一次字符串交换能否使两个字符串相等

### zip () 函数

`zip()` 函数是 Python 内置的一个函数，用于将多个序列按照相同的索引进行组合。`zip()` 函数返回的是一个 zip 对象，可以通过 `list()` 转换成列表或者直接用于迭代。

`zip()` 函数的语法为：

```python
zip(*iterables)
```

其中，`iterables` 是一个或多个序列，可以是列表、元组、集合、字典等可迭代对象。`zip()` 函数会以所有序列中最短的序列长度为准，将所有序列中相同索引位置的元素打包成一个元组，返回一个由这些元组组成的 zip 对象。如果不同序列长度不同，那么只有最短的那个序列中的元素会被组合。

例如，如果有两个列表 `a = [1, 2, 3]` 和 `b = [4, 5, 6]`，则可以使用 `zip()` 函数将它们组合成一个新的列表：

```python
c = zip(a, b)
list(c)  # [(1, 4), (2, 5), (3, 6)]
```

`zip()` 函数可以用于多个序列的循环遍历，简化代码实现，如下所示：

```python
for x, y in zip(a, b):
    print(x, y)
```

这样，`x` 就会依次取 `a` 列表中的元素，`y` 会依次取 `b` 列表中的元素，方便进行一些并行操作。

### enumerate() 函数

`enumerate()` 函数是 Python 内置函数之一，用于将一个可遍历的数据对象（如列表、元组或字符串）组合为一个带有索引的枚举对象，同时可以指定起始索引值。其用法如下：

```python
enumerate(iterable, start=0)
```

其中 `iterable` 为要枚举的可遍历数据对象，`start` 是指定索引的起始值，默认为 0。

`enumerate()` 函数会返回一个可迭代的枚举对象，每个元素为一个二元组，格式为 `(index, value)`，其中 `index` 是索引值，`value` 是枚举的元素值。例如：

```python
fruits = ['apple', 'banana', 'cherry']
for index, value in enumerate(fruits):
    print(index, value)
```

输出：

```
0 apple
1 banana
2 cherry
```

在循环中使用 `enumerate()` 函数可以方便地获取元素的索引值，可以省去手动计数的麻烦，同时也使代码更加简洁易读。

# DAY 5：函数

## 589. N 叉树的前序遍历

### 接口封装

在编程中，我们通常将一些数据或操作封装到类的内部，提供外部的接口来对类进行操作，这就是面向对象编程的基本思想之一——封装性。

对于二叉树这种数据结构，我们可以使用类来实现，并提供对外的接口来实现基本操作，比如插入、删除、查找等。其中，insert方法就是二叉树类对外暴露的插入接口，外部程序只需要调用该方法，就可以在二叉树中插入一个节点。而insert_node方法则是二叉树类的内部方法，是具体实现插入节点操作的方法，因此只在类的内部使用，外部程序无法直接调用。

这样的设计有几个好处。首先，将插入节点的具体实现封装在类的内部，可以避免外部程序对二叉树数据结构的直接修改，从而保证了数据的完整性和正确性。其次，对外暴露一个接口，可以让外部程序更加方便地使用该类，并且在需要改变内部实现时，只需要修改对外接口而不需要修改外部程序的代码，提高了代码的可维护性和可重用性。

前序遍历是二叉树或n叉树遍历的一种方式，具体实现的逻辑过程如下：

1. 访问根节点（对于二叉树来说就是访问根节点，对于n叉树来说就是访问父节点）；
2. 对根节点的左子树（对于二叉树）或子节点（对于n叉树）进行前序遍历；
3. 对根节点的右子树（对于二叉树）或其他子节点进行前序遍历。

具体实现的代码可以写成一个递归函数，递归函数的基本逻辑如下：

1. 如果节点为空，直接返回；
2. 访问当前节点；
3. 遍历当前节点的子节点（对于n叉树）或左右子树（对于二叉树），对子节点或左右子树递归调用前序遍历函数。

以下是一个二叉树前序遍历的示例代码：

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        res = []
        if not root:
            return res
        res.append(root.val) # 访问根节点
        res.extend(self.preorderTraversal(root.left)) # 前序遍历左子树
        res.extend(self.preorderTraversal(root.right)) # 前序遍历右子树
        return res
```

对于n叉树的前序遍历，代码类似，只需要将二叉树的左右子树遍历改为n叉树的子节点遍历即可。

### extend() 函数和 append() 函数

`extend`是Python中的一个内置函数，用于在一个列表末尾一次性追加另一个可迭代对象中的所有元素。具体来说，它的语法如下：

```python
list.extend(iterable)
```

其中，`list`是要被追加元素的列表，`iterable`是一个可迭代对象，它可以是列表、元组、集合、字符串或其他可迭代的对象。`extend`方法将可迭代对象中的每个元素追加到列表中，返回值是 `None`。

在 Python 中，extend() 和 append() 函数都是用于将元素添加到列表中的方法。

- append() 用于将单个元素追加到列表的末尾，是修改原列表的原地操作。它只接受一个参数，并将该参数添加到列表中。
- extend() 接受一个可迭代对象（如列表、元组、字符串等）作为参数，并将其中的元素逐一追加到列表的末尾，也是修改原列表的原地操作。

区别在于，append() 是将一个元素添加到列表的末尾，而 extend() 是将多个元素追加到列表的末尾。如果需要添加一个列表作为一个元素到另一个列表中，则应该使用 append()。例如：

```python
a = [1, 2, 3]
b = [4, 5]
a.append(b)
print(a)   # [1, 2, 3, [4, 5]]
```

而如果需要将列表 b 的元素依次追加到列表 a 的末尾，则应该使用 extend()。例如：

```python
a = [1, 2, 3]
b = [4, 5]
a.extend(b)
print(a)   # [1, 2, 3, 4, 5]
```

总之，append() 和 extend() 都是用于修改列表的原地操作，但 append() 添加单个元素，而 extend() 添加多个元素。

### 面向对象编程

面向对象编程（Object-Oriented Programming，简称 OOP）是一种编程思想，将现实世界中的实体和其相应的行为抽象为程序中的对象和方法，通过对象之间的交互实现程序的设计与实现。面向对象编程中，对象是程序的基本单元，具有状态和行为，对象之间通过消息传递进行通信。对象可以封装数据和方法，数据和方法的访问可以通过访问修饰符来控制。通过继承和多态机制，可以方便地扩展和重用代码。在面向对象编程中，程序的设计和实现都是以对象为中心进行的，可以更加贴近实际问题的描述和解决。因此，面向对象编程被广泛应用于各种软件开发领域。

Python属于面向对象编程语言。在Python中，一切皆为对象，所有的数据类型都是类的实例，甚至包括函数。Python中使用类来创建对象，通过继承、多态、封装等面向对象编程的特性，可以更加方便地组织代码，提高代码的重用性和可读性。同时，Python还支持许多与面向对象编程相关的语法，比如类的定义、实例化、方法调用、继承等。

属于面向对象编程语言：

- Java
- Python
- Ruby
- C++
- C#
- Objective-C
- Smalltalk
- Swift
- PHP

不属于面向对象编程语言：

- C
- Assembly
- Fortran
- BASIC
- COBOL
- Pascal

虽然某些编程语言本身不是面向对象编程语言，但是它们也可以使用面向对象的技术。例如，C语言可以使用结构体来模拟类的概念，从而实现面向对象编程。

### n叉树

n叉树（N-ary Tree），也叫多叉树、度为n的树，是一种特殊的树形结构。与二叉树相比，n叉树每个节点可以有多个子节点。

n叉树的特性包括：

1. 根节点没有父节点，其他节点有一个父节点。
2. 每个节点有0到n个子节点。
3. 节点之间的子节点没有顺序，因此是无序的。

n叉树的应用场景很多，例如表示文件系统、组织结构等具有层级关系的数据。在n叉树上进行遍历操作，有深度优先遍历和广度优先遍历两种方式。

在 Python 中，可以使用类来定义一个 n 叉树，具体步骤如下：

1. 定义节点类 Node，其中包含 val 和 children 两个属性，分别表示节点的值和其子节点列表。代码如下：

```python
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children if children is not None else []
```

1. 定义 n 叉树类 NTree，其中包含一个根节点属性 root，以及相应的初始化方法和遍历方法。代码如下：

```python
class NTree:
    def __init__(self, root=None):
        self.root = root

    def preorder(self, root):
        if not root:
            return []
        res = [root.val]
        for child in root.children:
            res.extend(self.preorder(child))
        return res
```

在这里，我们使用了前序遍历的方法来遍历 n 叉树。

1. 创建一个 n 叉树实例，并对其进行操作。例如，创建一个示例树，并输出其前序遍历的结果。代码如下：

```python
# 创建一个示例树
root = Node(1)
node2 = Node(2)
node3 = Node(3)
node4 = Node(4)
node5 = Node(5)
node6 = Node(6)

root.children = [node3, node2, node4]
node3.children = [node5, node6]

# 创建 n 叉树实例
tree = NTree(root)

# 输出树的前序遍历结果
print(tree.preorder(root))  # 输出：[1, 3, 5, 6, 2, 4]
```

这样就完成了一个 n 叉树的定义和遍历。

## 496. 下一个更大元素 I

### 列表推导式

列表推导式（List comprehension）是一种简化 Python 代码的语法，用于快速创建新的列表。它的一般形式为：

```python
[expression for item in iterable if condition]
```

其中，`expression` 是一个表达式，用于生成新列表的元素；`item` 是 iterable 中的元素；`iterable` 是可迭代对象，如列表、元组、集合、字符串等；`condition` 是可选的，用于筛选 iterable 中的元素。

下面是一个例子，它使用列表推导式生成一个新的列表：

```python
# 生成一个包含 1 到 10 的平方数的列表
squares = [x**2 for x in range(1, 11)]
print(squares)  # 输出 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
```

在这个例子中，`range(1, 11)` 返回一个包含 1 到 10 的整数序列，`x**2` 是一个表达式，用于计算每个元素的平方，`for x in range(1, 11)` 遍历整数序列中的每个元素，将它们代入表达式中计算，生成一个新的包含平方数的列表。

列表推导式还可以包含条件语句，用于筛选 iterable 中的元素，例如：

```python
# 生成一个包含 1 到 10 中偶数的平方数的列表
squares = [x**2 for x in range(1, 11) if x % 2 == 0]
print(squares)  # 输出 [4, 16, 36, 64, 100]
```

在这个例子中，`if x % 2 == 0` 是一个条件语句，用于筛选 iterable 中的偶数，只有偶数才会被计算平方并加入新列表。

列表推导式还有其他用法。除了用来生成列表之外，它还可以用来过滤列表、嵌套循环、进行条件赋值等。

例如，以下代码用列表推导式过滤掉了一个列表中所有的负数元素：

```python
nums = [1, -2, 3, -4, 5, -6]
positive_nums = [num for num in nums if num > 0]
print(positive_nums) # 输出 [1, 3, 5]
```

又例如，以下代码用嵌套列表推导式生成一个二维矩阵：

```python
matrix = [[i*j for j in range(5)] for i in range(5)]
print(matrix)
# 输出 [[0, 0, 0, 0, 0], [0, 1, 2, 3, 4], [0, 2, 4, 6, 8], [0, 3, 6, 9, 12], [0, 4, 8, 12, 16]]
```

还有其他一些用法，可以根据具体情况灵活运用。

### 单调栈

单调栈是一种数据结构，它可以维护一个栈，使得栈中的元素单调递增或单调递减。具体来说，单调栈可以支持两种操作：push 和 pop。push 操作将元素加入栈中，pop 操作将栈顶元素弹出。但是，单调栈还有一个特殊的性质，就是每次 push 操作时，会将比新元素小的元素都弹出栈，从而保持栈的单调性。

单调栈通常用于需要寻找某个元素左侧或右侧第一个比它大或比它小的元素的问题。这种问题可以用单调栈来解决，时间复杂度为 O(n)，其中 n 是元素个数。

在Python中，可以使用列表（list）来实现栈的基本功能。栈的常用操作包括入栈（push）、出栈（pop）、获取栈顶元素（top）和判断栈是否为空（empty）等。

下面是Python中实现栈的基本语法：

1. 创建一个空列表作为栈：

```python
stack = []
```

1. 元素入栈，使用列表的 `append()` 方法：

```python
stack.append(element)
```

1. 元素出栈，使用列表的 `pop()` 方法：

```python
element = stack.pop()
```

1. 获取栈顶元素，使用列表的索引 `-1`：

```python
top_element = stack[-1]
```

1. 判断栈是否为空，使用列表的布尔值：

```python
if not stack:
    # 栈为空的处理逻辑
```

需要注意的是，在使用列表实现栈时，应该遵循先进后出的原则。也就是说，入栈的元素应该位于栈顶，出栈的元素应该是栈顶元素。

### 哈希表

在Python中，哈希表通常是使用字典（dict）来实现的。字典是一种无序的数据集合，由键和值组成。通过将键映射到值来实现快速查找和检索数据。

在Python中，可以使用字典的以下方法来操作哈希表：

- 创建一个字典：使用花括号 {} 或者 dict() 函数来创建一个字典对象。
- 添加元素：使用 dict[key] = value 的方式添加键值对，如果该键已经存在，则更新对应的值。
- 获取元素：使用 dict[key] 的方式获取指定键对应的值，如果该键不存在，则会抛出 KeyError 异常。可以使用 get() 方法来获取键对应的值，如果该键不存在，则返回默认值（默认为 None）。
- 删除元素：使用 del dict[key] 的方式删除指定键对应的键值对，如果该键不存在，则会抛出 KeyError 异常。
- 判断键是否存在：使用 in 或者 not in 运算符来判断指定的键是否在字典中存在。

下面是一个简单的例子，演示了如何使用字典实现哈希表：

```python
# 创建一个字典
my_dict = {"apple": 2, "banana": 3, "orange": 4}

# 添加一个元素
my_dict["peach"] = 5

# 获取一个元素
print(my_dict["apple"])  # 输出 2

# 删除一个元素
del my_dict["orange"]

# 判断一个键是否存在
if "peach" in my_dict:
    print("Peach is in the dictionary.")

# 遍历字典中的键值对
for key, value in my_dict.items():
    print(key, value)
```

输出结果为：

```python
2
Peach is in the dictionary.
apple 2
banana 3
peach 5
```

# DAY 6：数组

## 1672. 最富有客户的资产总量

### 二维列表的sum函数

在二维列表中，使用“sum”函数可以计算每个子列表（即每行或每列）中所有元素的和，或者计算整个二维列表中所有元素的和。以下是几个简单的例子：

1. 计算每行元素的和：

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
row_sums = [sum(row) for row in matrix]
print(row_sums)  # 输出 [6, 15, 24]
```

这个例子中，首先定义了一个二维列表“matrix”，其中每个子列表表示一行。然后使用列表推导式计算每行元素的和，即对每个子列表应用“sum”函数。

1. 计算每列元素的和：

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
col_sums = [sum(col) for col in zip(*matrix)]
print(col_sums)  # 输出 [12, 15, 18]
```

这个例子中，首先定义了一个二维列表“matrix”，其中每个子列表表示一列。然后使用“zip”函数和解包操作符“*”将所有行转置成列，并对每列应用“sum”函数，计算每列元素的和。

1. 计算整个二维列表中所有元素的和：

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
total_sum = sum(sum(row) for row in matrix)
print(total_sum)  # 输出 45
```

这个例子中，首先定义了一个二维列表“matrix”，然后使用嵌套的“sum”函数计算每行元素的和，并使用外层的“sum”函数计算所有和的总和，即整个二维列表中所有元素的和。

# DAY 7：数组































